// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: codes.sql

package db

import (
	"context"
	"time"
)

const createCode = `-- name: CreateCode :exec
INSERT INTO codes (
    username, code, img, description, performance, star, tags, created_at, updated_at, access
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
)
`

type CreateCodeParams struct {
	Username    string    `json:"username"`
	Code        string    `json:"code"`
	Img         []byte    `json:"img"`
	Description string    `json:"description"`
	Performance string    `json:"performance"`
	Star        []int64   `json:"star"`
	Tags        []string  `json:"tags"`
	CreatedAt   time.Time `json:"created_at"`
	UpdatedAt   time.Time `json:"updated_at"`
	Access      int64     `json:"access"`
}

func (q *Queries) CreateCode(ctx context.Context, arg CreateCodeParams) error {
	_, err := q.db.Exec(ctx, createCode,
		arg.Username,
		arg.Code,
		arg.Img,
		arg.Description,
		arg.Performance,
		arg.Star,
		arg.Tags,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Access,
	)
	return err
}

const deleteCode = `-- name: DeleteCode :exec
DELETE FROM codes
WHERE id = $1
`

func (q *Queries) DeleteCode(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteCode, id)
	return err
}

const getAllCodes = `-- name: GetAllCodes :many
SELECT id, username, code, img, description, performance, star, tags, created_at, updated_at, access FROM codes
ORDER BY created_at ASC
LIMIT $1
OFFSET $2
`

type GetAllCodesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetAllCodes(ctx context.Context, arg GetAllCodesParams) ([]*Codes, error) {
	rows, err := q.db.Query(ctx, getAllCodes, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Codes{}
	for rows.Next() {
		var i Codes
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Code,
			&i.Img,
			&i.Description,
			&i.Performance,
			&i.Star,
			&i.Tags,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Access,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllCodesByKeyword = `-- name: GetAllCodesByKeyword :many
SELECT id, username, code, img, description, performance, star, tags, created_at, updated_at, access FROM codes
WHERE
    username LIKE $1 OR
    code LIKE $2 OR
    description LIKE $3
ORDER BY created_at ASC
LIMIT $4
OFFSET $5
`

type GetAllCodesByKeywordParams struct {
	Username    string `json:"username"`
	Code        string `json:"code"`
	Description string `json:"description"`
	Limit       int32  `json:"limit"`
	Offset      int32  `json:"offset"`
}

func (q *Queries) GetAllCodesByKeyword(ctx context.Context, arg GetAllCodesByKeywordParams) ([]*Codes, error) {
	rows, err := q.db.Query(ctx, getAllCodesByKeyword,
		arg.Username,
		arg.Code,
		arg.Description,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Codes{}
	for rows.Next() {
		var i Codes
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Code,
			&i.Img,
			&i.Description,
			&i.Performance,
			&i.Star,
			&i.Tags,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Access,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllCodesByTag = `-- name: GetAllCodesByTag :many
SELECT id, username, code, img, description, performance, star, tags, created_at, updated_at, access FROM codes
WHERE
    $1 = ANY(tags) OR
    $2 = ANY(tags) AND
    $3 = ANY(tags) AND
    $4 = ANY(tags) AND
    $5 = ANY(tags) AND
    $6 = ANY(tags) AND
    $7 = ANY(tags) AND
    $8 = ANY(tags) AND
    $9 = ANY(tags) AND
    $10 = ANY(tags)
ORDER BY created_at ASC
LIMIT $11
OFFSET $12
`

type GetAllCodesByTagParams struct {
	Column1  interface{} `json:"column_1"`
	Column2  interface{} `json:"column_2"`
	Column3  interface{} `json:"column_3"`
	Column4  interface{} `json:"column_4"`
	Column5  interface{} `json:"column_5"`
	Column6  interface{} `json:"column_6"`
	Column7  interface{} `json:"column_7"`
	Column8  interface{} `json:"column_8"`
	Column9  interface{} `json:"column_9"`
	Column10 interface{} `json:"column_10"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
}

func (q *Queries) GetAllCodesByTag(ctx context.Context, arg GetAllCodesByTagParams) ([]*Codes, error) {
	rows, err := q.db.Query(ctx, getAllCodesByTag,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
		arg.Column7,
		arg.Column8,
		arg.Column9,
		arg.Column10,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Codes{}
	for rows.Next() {
		var i Codes
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Code,
			&i.Img,
			&i.Description,
			&i.Performance,
			&i.Star,
			&i.Tags,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Access,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllCodesSortedAccess = `-- name: GetAllCodesSortedAccess :many
SELECT id, username, code, img, description, performance, star, tags, created_at, updated_at, access FROM codes
ORDER BY access DESC
LIMIT $1
OFFSET $2
`

type GetAllCodesSortedAccessParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetAllCodesSortedAccess(ctx context.Context, arg GetAllCodesSortedAccessParams) ([]*Codes, error) {
	rows, err := q.db.Query(ctx, getAllCodesSortedAccess, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Codes{}
	for rows.Next() {
		var i Codes
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Code,
			&i.Img,
			&i.Description,
			&i.Performance,
			&i.Star,
			&i.Tags,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Access,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllCodesSortedStar = `-- name: GetAllCodesSortedStar :many
SELECT id, username, code, img, description, performance, star, tags, created_at, updated_at, access FROM codes
ORDER BY array_length(star, 1) ASC
LIMIT $1
OFFSET $2
`

type GetAllCodesSortedStarParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetAllCodesSortedStar(ctx context.Context, arg GetAllCodesSortedStarParams) ([]*Codes, error) {
	rows, err := q.db.Query(ctx, getAllCodesSortedStar, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Codes{}
	for rows.Next() {
		var i Codes
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Code,
			&i.Img,
			&i.Description,
			&i.Performance,
			&i.Star,
			&i.Tags,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Access,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllOwnCodes = `-- name: GetAllOwnCodes :many
SELECT id, username, code, img, description, performance, star, tags, created_at, updated_at, access FROM codes
WHERE username = $1
LIMIT $2
OFFSET $3
`

type GetAllOwnCodesParams struct {
	Username string `json:"username"`
	Limit    int32  `json:"limit"`
	Offset   int32  `json:"offset"`
}

func (q *Queries) GetAllOwnCodes(ctx context.Context, arg GetAllOwnCodesParams) ([]*Codes, error) {
	rows, err := q.db.Query(ctx, getAllOwnCodes, arg.Username, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Codes{}
	for rows.Next() {
		var i Codes
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Code,
			&i.Img,
			&i.Description,
			&i.Performance,
			&i.Star,
			&i.Tags,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Access,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCode = `-- name: GetCode :one
SELECT id, username, code, img, description, performance, star, tags, created_at, updated_at, access FROM codes
WHERE id = $1
`

func (q *Queries) GetCode(ctx context.Context, id int64) (*Codes, error) {
	row := q.db.QueryRow(ctx, getCode, id)
	var i Codes
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Code,
		&i.Img,
		&i.Description,
		&i.Performance,
		&i.Star,
		&i.Tags,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Access,
	)
	return &i, err
}

const updateAccess = `-- name: UpdateAccess :exec
UPDATE codes
SET access = $2
WHERE id = $1
`

type UpdateAccessParams struct {
	ID     int64 `json:"id"`
	Access int64 `json:"access"`
}

func (q *Queries) UpdateAccess(ctx context.Context, arg UpdateAccessParams) error {
	_, err := q.db.Exec(ctx, updateAccess, arg.ID, arg.Access)
	return err
}

const updateCode = `-- name: UpdateCode :exec
UPDATE codes
SET code = $2,
    img = $3,
    description = $4,
    performance = $5,
    tags = $6,
    updated_at = $7
WHERE id = $1
`

type UpdateCodeParams struct {
	ID          int64     `json:"id"`
	Code        string    `json:"code"`
	Img         []byte    `json:"img"`
	Description string    `json:"description"`
	Performance string    `json:"performance"`
	Tags        []string  `json:"tags"`
	UpdatedAt   time.Time `json:"updated_at"`
}

func (q *Queries) UpdateCode(ctx context.Context, arg UpdateCodeParams) error {
	_, err := q.db.Exec(ctx, updateCode,
		arg.ID,
		arg.Code,
		arg.Img,
		arg.Description,
		arg.Performance,
		arg.Tags,
		arg.UpdatedAt,
	)
	return err
}

const updateStar = `-- name: UpdateStar :exec
UPDATE codes
SET star = $2
WHERE id = $1
`

type UpdateStarParams struct {
	ID   int64   `json:"id"`
	Star []int64 `json:"star"`
}

func (q *Queries) UpdateStar(ctx context.Context, arg UpdateStarParams) error {
	_, err := q.db.Exec(ctx, updateStar, arg.ID, arg.Star)
	return err
}
